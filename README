crash-testing
=============

Please refer to main branch for detailed usage.

About arch_dep branch
---------------------
Crash internally support many commands, such as bt/vtop/ptov etc. But they are 
all void functions, so they don't give exit values like bash $?, making it hard 
to identify whether a command has been executed correctly or not. Eg: giving an 
illegal address to vtop. A failing command maybe an identification of bug and 
regression error. So it's valuable for crash testing.

The best way to get improved is to modify the command functions within crash 
source code from "void" to return "int". It also may involve a lot of work, 
and seems only useful for automatic testing currently.

Another way to identify error command executing is to filter the error messages.
(The main branch is implemented in this way). If a command execution fails, 
it will print specific error message. But it may be lack of agility, when we
have to deal with a lot of different existing error messages, and keep track
of new error massages in the future.

I have made a mechanism for error log filtering in directory hook/ and 
log_filter.sh. The idea is to hack the error processing function in crash at 
runtime. Whenever a command fails, it will call a universal error processing 
function "int __error(int, char *, ...)". It will deal with "FATAL/INFO/NOTE..." 
cases. When hacked successfully, everytime crash calls __error will output a 
string "<<<-->>>" as well, which can be identified easily.

The reason of hacking crash at runtime, is that when doing regression testing, 
we may choose 2 old and new versions of crash. Runtime means no source code 
dependency, thus we can pick any crash (built from source, yum installed in 
binary form, copied from an old computer, etc). If backward compatibility is 
important, then runtime hacking is recommended. Besides, runtime hacking is 
happened only in memory, will have no side effect to disk files.

In x86/x86_64 arch, function calling is achieved by instruction 
"call xx xx xx xx". The xx is the offset address of the target function. So 
the basic idea of hacking is to modify the address to our customized function. 
After finishing our bussiness (print identification string), we then jump back 
to the original function to proceed.

The hacking is arch dependent, if we want to extend it to ARM/ppc/s390, we 
need to implement separately. In addition, when in x86_64, the "call xx xx xx xx" 
only have 32bit offset, may not be enough for 64bit address far jump. Thus I 
allocated a trampoline at the start of heap, then doing 64bit far jump there, 
thus it will ask for heap execution permission when selinux is in enforcing status.